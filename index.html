<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Stock Quick Predictor — No login (debugged)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:18px;background:#f7f8fb;color:#111}
    .card{background:#fff;padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(20,30,60,0.08);max-width:980px;margin:auto}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px}
    input,select,button{padding:8px 10px;border-radius:8px;border:1px solid #d6d9e6}
    button{cursor:pointer}
    small.gray{color:#666}
    .warn{color:#8a2b2b}
    .muted{color:#666;font-size:13px}
    .ok{color:#176f2b}
    .err{color:#8a2b2b}
    .controls{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
    #status{margin-top:8px}
  </style>
</head>
<body>
  <div class="card">
    <h2>Stock Quick Predictor (no login) — Debugged</h2>

    <div class="row">
      <input id="symbol" placeholder="Ticker (e.g. AAPL, MSFT, GOOGL)" style="flex:1" value="AAPL">
      <select id="range">
        <option value="1mo">1 month</option>
        <option value="3mo">3 months</option>
        <option value="6mo">6 months</option>
        <option value="1y">1 year</option>
        <option value="2y">2 years</option>
      </select>
      <select id="model">
        <option value="lr">Linear regression (simple)</option>
        <option value="ema">Exponential smoothing (alpha=0.3)</option>
        <option value="last">Last-price trend (naive)</option>
      </select>
      <input id="days" type="number" min="1" max="60" value="14" style="width:88px">
      <button id="go">Fetch & Predict</button>
    </div>

    <div class="controls">
      <button id="testA">Test AAPL</button>
      <button id="testM">Test MSFT</button>
      <button id="demo">Load Demo Data</button>
      <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="useProxy"> Use CORS proxy fallback</label>
      <button id="simulateOffline">Simulate Offline Error</button>
      <input id="csvfile" type="file" accept=".csv" title="Upload CSV with date,close columns">
      <button id="helpBtn">Help</button>
    </div>

    <div class="row">
      <div><strong>Current:</strong> <span id="current">—</span></div>
      <div><strong>Change:</strong> <span id="change">—</span></div>
      <div><small class="gray">Data source: Yahoo Finance unofficial JSON endpoint. Predictions are simple math models for demonstration only.</small></div>
    </div>

    <div id="status" class="muted">Ready</div>

    <canvas id="chart" height="240"></canvas>
    <p class="warn"><strong>Warning:</strong> This tool is educational. Predictions are simplistic and not financial advice. Use at your own risk.</p>

    <div style="margin-top:8px;font-size:13px">
      <strong>Notes for debugging:</strong>
      <ul>
        <li>If you see <code>TypeError: Load failed</code> or <code>Failed to fetch</code>, the environment may block outgoing network requests. Use <em>Load Demo Data</em> or upload a CSV to continue testing.</li>
        <li>Toggles: enable <em>Use CORS proxy fallback</em> to try a public proxy if direct fetch fails (may or may not work depending on environment).</li>
      </ul>
    </div>
  </div>

<script>
// ----------------- Utilities -----------------
function setStatus(txt, cls){
  const s = document.getElementById('status');
  s.textContent = txt;
  s.className = cls || 'muted';
}

function formatNumber(n){ return (typeof n === 'number' && !Number.isNaN(n)) ? n.toFixed(2) : '—'; }

// ----------------- Fetch with fallback -----------------
let simulateOffline = false;
async function fetchWithFallback(url, useProxy){
  // If the sandbox forbids network, this may throw a TypeError: Failed to fetch / Load failed.
  if(simulateOffline) throw new TypeError('Simulated offline (for testing)');

  // Helper to attempt a fetch and parse as JSON
  async function tryFetch(u){
    const res = await fetch(u);
    if(!res.ok) throw new Error('HTTP '+res.status);
    // Try to parse JSON; if that fails, try to parse text then JSON.parse
    try { return await res.json(); }
    catch(e){
      const txt = await res.text();
      try{ return JSON.parse(txt); }catch(err){ throw new Error('Response not JSON'); }
    }
  }

  try{
    return await tryFetch(url);
  }catch(err){
    console.warn('Direct fetch failed:', err);
    // If caller opted into proxy fallback, try public proxies
    if(!useProxy) throw err;

    const proxies = [
      'https://api.allorigins.win/raw?url=',      // AllOrigins raw proxy
      'https://thingproxy.freeboard.io/fetch/',  // thingproxy
      'https://cors.bridged.cc/'                  // bridged.cc
    ];

    for(const p of proxies){
      try{
        const prox = p + encodeURIComponent(url);
        setStatus('Trying proxy: '+p.split('/')[2]+' ...', 'muted');
        const j = await tryFetch(prox);
        setStatus('Got data via proxy: '+p.split('/')[2], 'ok');
        return j;
      }catch(e){
        console.warn('Proxy failed:', p, e);
      }
    }
    // all proxies failed
    throw err;
  }
}

// ----------------- Yahoo chart fetch wrapper -----------------
async function fetchYahooChart(symbol, range, useProxy){
  const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(symbol)}?range=${encodeURIComponent(range)}&interval=1d&includePrePost=false`;
  return fetchWithFallback(url, useProxy);
}

// ----------------- Parsing -----------------
function parseChart(json){
  const chartRes = json && json.chart && json.chart.result && json.chart.result[0];
  if(!chartRes) throw new Error('No chart result in response');
  const timestamps = chartRes.timestamp || [];
  const rawCloses = (chartRes.indicators && chartRes.indicators.quote && chartRes.indicators.quote[0] && chartRes.indicators.quote[0].close) || [];
  const meta = chartRes.meta || {};

  // Build aligned arrays skipping null/NaN closes (keeps labels matched to closes)
  const labelsAll = timestamps.map(ts=>{ const d = new Date(ts*1000); return d.toISOString().slice(0,10); });
  const labels = [];
  const closes = [];
  for(let i=0;i<rawCloses.length && i<labelsAll.length;i++){
    const v = rawCloses[i];
    if(v !== null && !Number.isNaN(v)){
      labels.push(labelsAll[i]);
      closes.push(v);
    }
  }
  return {labels, closes, meta};
}

// ----------------- Prediction models -----------------
function linearRegressionPredict(y, n){
  const m = y.length;
  if(m===0) return [];
  const xs = [...Array(m).keys()];
  const meanX = xs.reduce((a,b)=>a+b,0)/m;
  const meanY = y.reduce((a,b)=>a+b,0)/m;
  let num=0, den=0;
  for(let i=0;i<m;i++){ num += (xs[i]-meanX)*(y[i]-meanY); den += (xs[i]-meanX)**2; }
  const slope = den===0?0:num/den;
  const intercept = meanY - slope*meanX;
  const preds = [];
  for(let k=1;k<=n;k++){
    const x = m-1 + k;
    preds.push(intercept + slope*x);
  }
  return preds;
}

function emaPredict(y,n,alpha=0.3){
  if(y.length===0) return [];
  // compute EMA across the series
  let s = y[0];
  for(let i=1;i<y.length;i++) s = alpha*y[i] + (1-alpha)*s;
  // naive forecast: repeat last EMA for future days
  return Array(n).fill(s);
}

function naivePredict(y,n){
  if(y.length===0) return [];
  const diffs = [];
  for(let i=1;i<y.length;i++) diffs.push(y[i]-y[i-1]);
  const avgDiff = diffs.length?diffs.reduce((a,b)=>a+b,0)/diffs.length:0;
  const preds = [];
  let last = y[y.length-1];
  for(let k=0;k<n;k++){
    last = last + avgDiff;
    preds.push(last);
  }
  return preds;
}

// ----------------- Chart drawing -----------------
let chart = null;
function drawChart(labels, closes, predLabels, predValues){
  const ctx = document.getElementById('chart').getContext('2d');
  const fullLabels = labels.concat(predLabels);
  const dataActual = closes.concat(Array(predValues.length).fill(null));
  const dataPred = Array(closes.length).fill(null).concat(predValues);
  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: fullLabels,
      datasets: [
        { label:'Close', data: dataActual, tension:0.18, borderWidth:2, spanGaps:false },
        { label:'Prediction', data: dataPred, tension:0.18, borderDash:[6,6], borderWidth:2 }
      ]
    },
    options: {plugins:{legend:{position:'top'}}, scales:{x:{display:true}, y:{display:true}}}
  });
}

// ----------------- Demo data / CSV -----------------
function demoData(){
  // 40 days of synthetic demo series (simple sine + trend)
  const labels = [];
  const closes = [];
  const now = new Date();
  for(let i=40;i>0;i--){
    const d = new Date(now);
    d.setDate(d.getDate()-i);
    labels.push(d.toISOString().slice(0,10));
    const base = 150 + (40-i)*0.3 + Math.sin(i/3)*3;
    closes.push(Number((base + (Math.random()-0.5)*2).toFixed(2)));
  }
  return {labels, closes, meta:{currency:'USD'}};
}

function parseCSVText(txt){
  // Expect CSV with header containing date and close (case-insensitive). Simple parser.
  const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  if(lines.length<2) throw new Error('CSV must have header + at least one row');
  const header = lines[0].split(/,|;|\t/).map(h=>h.trim().toLowerCase());
  const dateIdx = header.findIndex(h=>h.includes('date'));
  const closeIdx = header.findIndex(h=>h.includes('close')||h.includes('price'));
  if(dateIdx===-1 || closeIdx===-1) throw new Error('CSV header needs date and close columns');
  const labels=[]; const closes=[];
  for(let i=1;i<lines.length;i++){
    const cols = lines[i].split(/,|;|\t/).map(c=>c.trim());
    if(cols.length<=Math.max(dateIdx,closeIdx)) continue;
    const d = cols[dateIdx];
    const c = parseFloat(cols[closeIdx].replace(/[^0-9.-]/g,''));
    if(!d || Number.isNaN(c)) continue;
    labels.push(new Date(d).toISOString().slice(0,10));
    closes.push(c);
  }
  if(!labels.length) throw new Error('No valid rows found in CSV');
  return {labels, closes, meta:{currency:''}};
}

// ----------------- Main runner -----------------
async function run(symbol, range, model, days, opts={useProxy:false, fromDemo:false, csvData:null}){
  document.getElementById('current').textContent='Loading...';
  document.getElementById('change').textContent='';
  setStatus('Fetching data...', 'muted');

  try{
    let labels, closes, meta;
    if(opts.fromDemo){
      const d = demoData(); labels=d.labels; closes=d.closes; meta=d.meta; setStatus('Using demo data', 'ok');
    }else if(opts.csvData){
      const parsed = parseCSVText(opts.csvData); labels=parsed.labels; closes=parsed.closes; meta=parsed.meta; setStatus('Using CSV data', 'ok');
    }else{
      const json = await fetchYahooChart(symbol, range, opts.useProxy);
      const parsed = parseChart(json);
      labels = parsed.labels; closes = parsed.closes; meta = parsed.meta;
      setStatus('Fetched live data', 'ok');
    }

    if(!closes || closes.length===0) throw new Error('No close prices available from data source');

    // Current & change (try meta else derive from closes)
    const current = (meta && meta.regularMarketPrice) || closes[closes.length-1];
    const prevClose = (meta && meta.chartPreviousClose) || closes[closes.length-2] || closes[closes.length-1];
    document.getElementById('current').textContent = (current!==undefined?formatNumber(current):'—') + ` (${meta && meta.currency ? meta.currency : ''})`;
    if(current!==undefined && prevClose!==undefined){
      const ch = current - prevClose;
      const pct = prevClose? (ch/prevClose)*100 : 0;
      document.getElementById('change').textContent = (ch>=0?'+':'')+formatNumber(ch)+` (${pct.toFixed(2)}%)`;
    }

    // prediction
    let preds;
    if(model==='lr') preds = linearRegressionPredict(closes, days);
    else if(model==='ema') preds = emaPredict(closes, days, 0.3);
    else preds = naivePredict(closes, days);

    const lastDate = labels.length?new Date(labels[labels.length-1]):new Date();
    const predLabels = [];
    for(let i=1;i<=days;i++){
      const d = new Date(lastDate);
      d.setDate(d.getDate()+i);
      predLabels.push(d.toISOString().slice(0,10));
    }

    drawChart(labels, closes, predLabels, preds.map(v=>Number(v.toFixed(2))));
  }catch(err){
    console.error(err);
    document.getElementById('current').textContent = 'Error';
    document.getElementById('change').textContent = err.message || String(err);
    setStatus('Error: '+(err.message||err), 'err');
  }
}

// ----------------- UI wiring -----------------
document.getElementById('go').addEventListener('click', ()=>{
  const sym = document.getElementById('symbol').value.trim();
  const range = document.getElementById('range').value;
  const model = document.getElementById('model').value;
  const days = parseInt(document.getElementById('days').value)||14;
  const useProxy = document.getElementById('useProxy').checked;
  run(sym, range, model, days, {useProxy});
});

document.getElementById('testA').addEventListener('click', ()=>{
  document.getElementById('symbol').value = 'AAPL';
  document.getElementById('range').value = '1mo';
  document.getElementById('model').value = 'lr';
  document.getElementById('days').value = '14';
  document.getElementById('useProxy').checked = true;
  document.getElementById('go').click();
});

document.getElementById('testM').addEventListener('click', ()=>{
  document.getElementById('symbol').value = 'MSFT';
  document.getElementById('range').value = '3mo';
  document.getElementById('model').value = 'ema';
  document.getElementById('days').value = '21';
  document.getElementById('useProxy').checked = true;
  document.getElementById('go').click();
});

document.getElementById('demo').addEventListener('click', ()=>{
  const model = document.getElementById('model').value;
  const days = parseInt(document.getElementById('days').value)||14;
  run('DEMO','1mo', model, days, {fromDemo:true});
});

document.getElementById('simulateOffline').addEventListener('click', ()=>{
  simulateOffline = true;
  setTimeout(()=>simulateOffline=false, 5000);
  setStatus('Simulating offline network for 5s', 'muted');
});

// CSV upload
document.getElementById('csvfile').addEventListener('change', (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = function(e){
    try{
      run('', '', document.getElementById('model').value, parseInt(document.getElementById('days').value)||14, {csvData: e.target.result});
    }catch(err){
      setStatus('CSV parse error: '+err.message, 'err');
    }
  };
  reader.readAsText(f);
});

// Help
document.getElementById('helpBtn').addEventListener('click', ()=>{
  alert('Troubleshooting tips:\n\n- If you get a network error, enable "Use CORS proxy fallback" to try public proxies.\n- If that still fails the environment may block outgoing network requests; use Demo Data or upload a CSV with columns date,close.\n- "Simulate Offline" will artificially block network for 5s to help reproduce the error.');
});

// Auto-run demo on load to show everything works without network
setTimeout(()=>{ document.getElementById('demo').click(); }, 250);
</script>
</body>
</html>
